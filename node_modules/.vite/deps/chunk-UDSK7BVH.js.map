{
  "version": 3,
  "sources": ["../../three/examples/jsm/utils/SkeletonUtils.js"],
  "sourcesContent": ["import {\n\tAnimationClip,\n\tAnimationMixer,\n\tMatrix4,\n\tQuaternion,\n\tQuaternionKeyframeTrack,\n\tSkeletonHelper,\n\tVector3,\n\tVectorKeyframeTrack\n} from 'three';\n\n/**\n * @module SkeletonUtils\n * @three_import import * as SkeletonUtils from 'three/addons/utils/SkeletonUtils.js';\n */\n\nfunction getBoneName( bone, options ) {\n\n\tif ( options.getBoneName !== undefined ) {\n\n\t\treturn options.getBoneName( bone );\n\n\t}\n\n\treturn options.names[ bone.name ];\n\n}\n\n/**\n * Retargets the skeleton from the given source 3D object to the\n * target 3D object.\n *\n * @param {Object3D} target - The target 3D object.\n * @param {Object3D} source - The source 3D object.\n * @param {module:SkeletonUtils~RetargetOptions} options - The options.\n */\nfunction retarget( target, source, options = {} ) {\n\n\tconst quat = new Quaternion(),\n\t\tscale = new Vector3(),\n\t\trelativeMatrix = new Matrix4(),\n\t\tglobalMatrix = new Matrix4();\n\n\toptions.preserveBoneMatrix = options.preserveBoneMatrix !== undefined ? options.preserveBoneMatrix : true;\n\toptions.preserveBonePositions = options.preserveBonePositions !== undefined ? options.preserveBonePositions : true;\n\toptions.useTargetMatrix = options.useTargetMatrix !== undefined ? options.useTargetMatrix : false;\n\toptions.hip = options.hip !== undefined ? options.hip : 'hip';\n\toptions.hipInfluence = options.hipInfluence !== undefined ? options.hipInfluence : new Vector3( 1, 1, 1 );\n\toptions.scale = options.scale !== undefined ? options.scale : 1;\n\toptions.names = options.names || {};\n\n\tconst sourceBones = source.isObject3D ? source.skeleton.bones : getBones( source ),\n\t\tbones = target.isObject3D ? target.skeleton.bones : getBones( target );\n\n\tlet bone, name, boneTo,\n\t\tbonesPosition;\n\n\t// reset bones\n\n\tif ( target.isObject3D ) {\n\n\t\ttarget.skeleton.pose();\n\n\t} else {\n\n\t\toptions.useTargetMatrix = true;\n\t\toptions.preserveBoneMatrix = false;\n\n\t}\n\n\tif ( options.preserveBonePositions ) {\n\n\t\tbonesPosition = [];\n\n\t\tfor ( let i = 0; i < bones.length; i ++ ) {\n\n\t\t\tbonesPosition.push( bones[ i ].position.clone() );\n\n\t\t}\n\n\t}\n\n\tif ( options.preserveBoneMatrix ) {\n\n\t\t// reset matrix\n\n\t\ttarget.updateMatrixWorld();\n\n\t\ttarget.matrixWorld.identity();\n\n\t\t// reset children matrix\n\n\t\tfor ( let i = 0; i < target.children.length; ++ i ) {\n\n\t\t\ttarget.children[ i ].updateMatrixWorld( true );\n\n\t\t}\n\n\t}\n\n\tfor ( let i = 0; i < bones.length; ++ i ) {\n\n\t\tbone = bones[ i ];\n\t\tname = getBoneName( bone, options );\n\n\t\tboneTo = getBoneByName( name, sourceBones );\n\n\t\tglobalMatrix.copy( bone.matrixWorld );\n\n\t\tif ( boneTo ) {\n\n\t\t\tboneTo.updateMatrixWorld();\n\n\t\t\tif ( options.useTargetMatrix ) {\n\n\t\t\t\trelativeMatrix.copy( boneTo.matrixWorld );\n\n\t\t\t} else {\n\n\t\t\t\trelativeMatrix.copy( target.matrixWorld ).invert();\n\t\t\t\trelativeMatrix.multiply( boneTo.matrixWorld );\n\n\t\t\t}\n\n\t\t\t// ignore scale to extract rotation\n\n\t\t\tscale.setFromMatrixScale( relativeMatrix );\n\t\t\trelativeMatrix.scale( scale.set( 1 / scale.x, 1 / scale.y, 1 / scale.z ) );\n\n\t\t\t// apply to global matrix\n\n\t\t\tglobalMatrix.makeRotationFromQuaternion( quat.setFromRotationMatrix( relativeMatrix ) );\n\n\t\t\tif ( target.isObject3D ) {\n\n\t\t\t\tif ( options.localOffsets ) {\n\n\t\t\t\t\tif ( options.localOffsets[ bone.name ] ) {\n\n\t\t\t\t\t\tglobalMatrix.multiply( options.localOffsets[ bone.name ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tglobalMatrix.copyPosition( relativeMatrix );\n\n\t\t}\n\n\t\tif ( name === options.hip ) {\n\n\t\t\tglobalMatrix.elements[ 12 ] *= options.scale * options.hipInfluence.x;\n\t\t\tglobalMatrix.elements[ 13 ] *= options.scale * options.hipInfluence.y;\n\t\t\tglobalMatrix.elements[ 14 ] *= options.scale * options.hipInfluence.z;\n\n\t\t\tif ( options.hipPosition !== undefined ) {\n\n\t\t\t\tglobalMatrix.elements[ 12 ] += options.hipPosition.x * options.scale;\n\t\t\t\tglobalMatrix.elements[ 13 ] += options.hipPosition.y * options.scale;\n\t\t\t\tglobalMatrix.elements[ 14 ] += options.hipPosition.z * options.scale;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( bone.parent ) {\n\n\t\t\tbone.matrix.copy( bone.parent.matrixWorld ).invert();\n\t\t\tbone.matrix.multiply( globalMatrix );\n\n\t\t} else {\n\n\t\t\tbone.matrix.copy( globalMatrix );\n\n\t\t}\n\n\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\n\n\t\tbone.updateMatrixWorld();\n\n\t}\n\n\tif ( options.preserveBonePositions ) {\n\n\t\tfor ( let i = 0; i < bones.length; ++ i ) {\n\n\t\t\tbone = bones[ i ];\n\t\t\tname = getBoneName( bone, options ) || bone.name;\n\n\t\t\tif ( name !== options.hip ) {\n\n\t\t\t\tbone.position.copy( bonesPosition[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tif ( options.preserveBoneMatrix ) {\n\n\t\t// restore matrix\n\n\t\ttarget.updateMatrixWorld( true );\n\n\t}\n\n}\n\n/**\n * Retargets the animation clip of the source object to the\n * target 3D object.\n *\n * @param {Object3D} target - The target 3D object.\n * @param {Object3D} source - The source 3D object.\n * @param {AnimationClip} clip - The animation clip.\n * @param {module:SkeletonUtils~RetargetOptions} options - The options.\n * @return {AnimationClip} The retargeted animation clip.\n */\nfunction retargetClip( target, source, clip, options = {} ) {\n\n\toptions.useFirstFramePosition = options.useFirstFramePosition !== undefined ? options.useFirstFramePosition : false;\n\n\t// Calculate the fps from the source clip based on the track with the most frames, unless fps is already provided.\n\toptions.fps = options.fps !== undefined ? options.fps : ( Math.max( ...clip.tracks.map( track => track.times.length ) ) / clip.duration );\n\toptions.names = options.names || [];\n\n\tif ( ! source.isObject3D ) {\n\n\t\tsource = getHelperFromSkeleton( source );\n\n\t}\n\n\tconst numFrames = Math.round( clip.duration * ( options.fps / 1000 ) * 1000 ),\n\t\tdelta = clip.duration / ( numFrames - 1 ),\n\t\tconvertedTracks = [],\n\t\tmixer = new AnimationMixer( source ),\n\t\tbones = getBones( target.skeleton ),\n\t\tboneDatas = [];\n\n\tlet positionOffset,\n\t\tbone, boneTo, boneData,\n\t\tname;\n\n\tmixer.clipAction( clip ).play();\n\n\t// trim\n\n\tlet start = 0, end = numFrames;\n\n\tif ( options.trim !== undefined ) {\n\n\t\tstart = Math.round( options.trim[ 0 ] * options.fps );\n\t\tend = Math.min( Math.round( options.trim[ 1 ] * options.fps ), numFrames ) - start;\n\n\t\tmixer.update( options.trim[ 0 ] );\n\n\t} else {\n\n\t\tmixer.update( 0 );\n\n\t}\n\n\tsource.updateMatrixWorld();\n\n\t//\n\n\tfor ( let frame = 0; frame < end; ++ frame ) {\n\n\t\tconst time = frame * delta;\n\n\t\tretarget( target, source, options );\n\n\t\tfor ( let j = 0; j < bones.length; ++ j ) {\n\n\t\t\tbone = bones[ j ];\n\t\t\tname = getBoneName( bone, options ) || bone.name;\n\t\t\tboneTo = getBoneByName( name, source.skeleton );\n\n\t\t\tif ( boneTo ) {\n\n\t\t\t\tboneData = boneDatas[ j ] = boneDatas[ j ] || { bone: bone };\n\n\t\t\t\tif ( options.hip === name ) {\n\n\t\t\t\t\tif ( ! boneData.pos ) {\n\n\t\t\t\t\t\tboneData.pos = {\n\t\t\t\t\t\t\ttimes: new Float32Array( end ),\n\t\t\t\t\t\t\tvalues: new Float32Array( end * 3 )\n\t\t\t\t\t\t};\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( options.useFirstFramePosition ) {\n\n\t\t\t\t\t\tif ( frame === 0 ) {\n\n\t\t\t\t\t\t\tpositionOffset = bone.position.clone();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbone.position.sub( positionOffset );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tboneData.pos.times[ frame ] = time;\n\n\t\t\t\t\tbone.position.toArray( boneData.pos.values, frame * 3 );\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! boneData.quat ) {\n\n\t\t\t\t\tboneData.quat = {\n\t\t\t\t\t\ttimes: new Float32Array( end ),\n\t\t\t\t\t\tvalues: new Float32Array( end * 4 )\n\t\t\t\t\t};\n\n\t\t\t\t}\n\n\t\t\t\tboneData.quat.times[ frame ] = time;\n\n\t\t\t\tbone.quaternion.toArray( boneData.quat.values, frame * 4 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( frame === end - 2 ) {\n\n\t\t\t// last mixer update before final loop iteration\n\t\t\t// make sure we do not go over or equal to clip duration\n\t\t\tmixer.update( delta - 0.0000001 );\n\n\t\t} else {\n\n\t\t\tmixer.update( delta );\n\n\t\t}\n\n\t\tsource.updateMatrixWorld();\n\n\t}\n\n\tfor ( let i = 0; i < boneDatas.length; ++ i ) {\n\n\t\tboneData = boneDatas[ i ];\n\n\t\tif ( boneData ) {\n\n\t\t\tif ( boneData.pos ) {\n\n\t\t\t\tconvertedTracks.push( new VectorKeyframeTrack(\n\t\t\t\t\t'.bones[' + boneData.bone.name + '].position',\n\t\t\t\t\tboneData.pos.times,\n\t\t\t\t\tboneData.pos.values\n\t\t\t\t) );\n\n\t\t\t}\n\n\t\t\tconvertedTracks.push( new QuaternionKeyframeTrack(\n\t\t\t\t'.bones[' + boneData.bone.name + '].quaternion',\n\t\t\t\tboneData.quat.times,\n\t\t\t\tboneData.quat.values\n\t\t\t) );\n\n\t\t}\n\n\t}\n\n\tmixer.uncacheAction( clip );\n\n\treturn new AnimationClip( clip.name, - 1, convertedTracks );\n\n}\n\n/**\n * Clones the given 3D object and its descendants, ensuring that any `SkinnedMesh` instances are\n * correctly associated with their bones. Bones are also cloned, and must be descendants of the\n * object passed to this method. Other data, like geometries and materials, are reused by reference.\n *\n * @param {Object3D} source - The 3D object to clone.\n * @return {Object3D} The cloned 3D object.\n */\nfunction clone( source ) {\n\n\tconst sourceLookup = new Map();\n\tconst cloneLookup = new Map();\n\n\tconst clone = source.clone();\n\n\tparallelTraverse( source, clone, function ( sourceNode, clonedNode ) {\n\n\t\tsourceLookup.set( clonedNode, sourceNode );\n\t\tcloneLookup.set( sourceNode, clonedNode );\n\n\t} );\n\n\tclone.traverse( function ( node ) {\n\n\t\tif ( ! node.isSkinnedMesh ) return;\n\n\t\tconst clonedMesh = node;\n\t\tconst sourceMesh = sourceLookup.get( node );\n\t\tconst sourceBones = sourceMesh.skeleton.bones;\n\n\t\tclonedMesh.skeleton = sourceMesh.skeleton.clone();\n\t\tclonedMesh.bindMatrix.copy( sourceMesh.bindMatrix );\n\n\t\tclonedMesh.skeleton.bones = sourceBones.map( function ( bone ) {\n\n\t\t\treturn cloneLookup.get( bone );\n\n\t\t} );\n\n\t\tclonedMesh.bind( clonedMesh.skeleton, clonedMesh.bindMatrix );\n\n\t} );\n\n\treturn clone;\n\n}\n\n// internal helper\n\nfunction getBoneByName( name, skeleton ) {\n\n\tfor ( let i = 0, bones = getBones( skeleton ); i < bones.length; i ++ ) {\n\n\t\tif ( name === bones[ i ].name )\n\n\t\t\treturn bones[ i ];\n\n\t}\n\n}\n\nfunction getBones( skeleton ) {\n\n\treturn Array.isArray( skeleton ) ? skeleton : skeleton.bones;\n\n}\n\n\nfunction getHelperFromSkeleton( skeleton ) {\n\n\tconst source = new SkeletonHelper( skeleton.bones[ 0 ] );\n\tsource.skeleton = skeleton;\n\n\treturn source;\n\n}\n\nfunction parallelTraverse( a, b, callback ) {\n\n\tcallback( a, b );\n\n\tfor ( let i = 0; i < a.children.length; i ++ ) {\n\n\t\tparallelTraverse( a.children[ i ], b.children[ i ], callback );\n\n\t}\n\n}\n\n/**\n * Retarget options of `SkeletonUtils`.\n *\n * @typedef {Object} module:SkeletonUtils~RetargetOptions\n * @property {boolean} [useFirstFramePosition=false] - Whether to use the position of the first frame or not.\n * @property {number} [fps] - The FPS of the clip.\n * @property {Object<string,string>} [names] - A dictionary for mapping target to source bone names.\n * @property {function(string):string} [getBoneName] - A function for mapping bone names. Alternative to `names`.\n * @property {Array<number>} [trim] - Whether to trim the clip or not. If set the array should hold two values for the start and end.\n * @property {boolean} [preserveBoneMatrix=true] - Whether to preserve bone matrices or not.\n * @property {boolean} [preserveBonePositions=true] - Whether to preserve bone positions or not.\n * @property {boolean} [useTargetMatrix=false] - Whether to use the target matrix or not.\n * @property {string} [hip='hip'] - The name of the source's hip bone.\n * @property {Vector3} [hipInfluence=(1,1,1)] - The hip influence.\n * @property {number} [scale=1] - The scale.\n **/\n\nexport {\n\tretarget,\n\tretargetClip,\n\tclone,\n};\n"],
  "mappings": "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",
  "names": ["clone"]
}
