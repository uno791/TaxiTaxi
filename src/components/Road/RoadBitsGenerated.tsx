/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 public/models/road-bits.glb -o src/components/RoadBitsGenerated.tsx -t
*/

import { useGLTF } from '@react-three/drei'
import type { GLTF } from 'three-stdlib'
import type * as THREE from 'three'
import type { JSX } from 'react/jsx-runtime'

// ----- Typed result for your model -----
type GLTFResult = GLTF & {
  nodes: {
    road_corner: THREE.Mesh
    road_corner_curved: THREE.Mesh
    road_junction: THREE.Mesh
    road_straight: THREE.Mesh
    road_straight_crossing: THREE.Mesh
    road_tsplit: THREE.Mesh
  }
  materials: {
    citybits_texture: THREE.MeshStandardMaterial
  }
  // animations: GLTFAction[] // not used; omit or import type if you need it
}

// ----- Default export: renders ALL pieces in a small grid -----
export default function RoadBits(props: JSX.IntrinsicElements['group']) {
  const { nodes, materials } = useGLTF('/models/road-bits.glb') as unknown as GLTFResult

  return (
    <group {...props} dispose={null}>
      <mesh
        geometry={nodes.road_corner.geometry}
        material={materials.citybits_texture}
        rotation={[-Math.PI / 2, 0, 0]}
        scale={100}
      />
      <mesh
        geometry={nodes.road_corner_curved.geometry}
        material={materials.citybits_texture}
        position={[3, 0, 0]}
        rotation={[-Math.PI / 2, 0, 0]}
        scale={100}
      />
      <mesh
        geometry={nodes.road_junction.geometry}
        material={materials.citybits_texture}
        position={[6, 0, 0]}
        rotation={[-Math.PI / 2, 0, 0]}
        scale={100}
      />
      <mesh
        geometry={nodes.road_straight.geometry}
        material={materials.citybits_texture}
        position={[0, 0, 3]}
        rotation={[-Math.PI / 2, 0, 0]}
        scale={100}
      />
      <mesh
        geometry={nodes.road_straight_crossing.geometry}
        material={materials.citybits_texture}
        position={[3, 0, 3]}
        rotation={[-Math.PI / 2, 0, 0]}
        scale={100}
      />
      <mesh
        geometry={nodes.road_tsplit.geometry}
        material={materials.citybits_texture}
        position={[6, 0, 3]}
        rotation={[-Math.PI / 2, 0, 0]}
        scale={100}
      />
    </group>
  )
}

// Preload for snappier first paint (âœ… path matches)
useGLTF.preload('/models/road-bits.glb')

/* ---------- Named piece components with sensible defaults + parent override ---------- */

type MeshProps = Omit<JSX.IntrinsicElements['mesh'], 'rotation' | 'scale'> & {
  rotation?: [number, number, number]
  scale?: number
}

export function RoadCorner({ rotation = [-Math.PI / 2, 0, 0], scale = 100, ...props }: MeshProps) {
  const { nodes, materials } = useGLTF('/models/road-bits.glb') as unknown as GLTFResult
  return (
    <mesh
      {...props}
      geometry={nodes.road_corner.geometry}
      material={materials.citybits_texture}
      scale={scale}
      rotation={rotation}
    />
  )
}

export function RoadCornerCurved({ rotation = [-Math.PI / 2, 0, 0], scale = 100, ...props }: MeshProps) {
  const { nodes, materials } = useGLTF('/models/road-bits.glb') as unknown as GLTFResult
  return (
    <mesh
      {...props}
      geometry={nodes.road_corner_curved.geometry}
      material={materials.citybits_texture}
      scale={scale}
      rotation={rotation}
    />
  )
}

export function RoadJunction({ rotation = [-Math.PI / 2, 0, 0], scale = 100, ...props }: MeshProps) {
  const { nodes, materials } = useGLTF('/models/road-bits.glb') as unknown as GLTFResult
  return (
    <mesh
      {...props}
      geometry={nodes.road_junction.geometry}
      material={materials.citybits_texture}
      scale={scale}
      rotation={rotation}
    />
  )
}

export function RoadStraight({ rotation = [-Math.PI / 2, 0, 0], scale = 100, ...props }: MeshProps) {
  const { nodes, materials } = useGLTF('/models/road-bits.glb') as unknown as GLTFResult
  return (
    <mesh
      {...props}
      geometry={nodes.road_straight.geometry}
      material={materials.citybits_texture}
      scale={scale}
      rotation={rotation}
    />
  )
}

export function RoadStraightCrossing({ rotation = [-Math.PI / 2, 0, 0], scale = 100, ...props }: MeshProps) {
  const { nodes, materials } = useGLTF('/models/road-bits.glb') as unknown as GLTFResult
  return (
    <mesh
      {...props}
      geometry={nodes.road_straight_crossing.geometry}
      material={materials.citybits_texture}
      scale={scale}
      rotation={rotation}
    />
  )
}

export function RoadTSplit({ rotation = [-Math.PI / 2, 0, 0], scale = 100, ...props }: MeshProps) {
  const { nodes, materials } = useGLTF('/models/road-bits.glb') as unknown as GLTFResult
  return (
    <mesh
      {...props}
      geometry={nodes.road_tsplit.geometry}
      material={materials.citybits_texture}
      scale={scale}
      rotation={rotation}
    />
  )
}


